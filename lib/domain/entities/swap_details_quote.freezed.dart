// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'swap_details_quote.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SwapDetailsQuote _$SwapDetailsQuoteFromJson(Map<String, dynamic> json) {
  return _SwapDetailsQuote.fromJson(json);
}

/// @nodoc
mixin _$SwapDetailsQuote {
  dynamic get chainId => throw _privateConstructorUsedError;
  dynamic get price => throw _privateConstructorUsedError;
  dynamic get grossPrice => throw _privateConstructorUsedError;
  dynamic get estimatedPriceImpact => throw _privateConstructorUsedError;
  dynamic get value => throw _privateConstructorUsedError;
  dynamic get gasPrice => throw _privateConstructorUsedError;
  dynamic get gas => throw _privateConstructorUsedError;
  dynamic get estimatedGas => throw _privateConstructorUsedError;
  dynamic get protocolFee => throw _privateConstructorUsedError;
  dynamic get minimumProtocolFee => throw _privateConstructorUsedError;
  dynamic get buyTokenAddress => throw _privateConstructorUsedError;
  dynamic get buyAmount => throw _privateConstructorUsedError;
  dynamic get grossBuyAmount => throw _privateConstructorUsedError;
  dynamic get sellTokenAddress => throw _privateConstructorUsedError;
  dynamic get sellAmount => throw _privateConstructorUsedError;
  dynamic get grossSellAmount => throw _privateConstructorUsedError;
  List<Source> get sources => throw _privateConstructorUsedError;
  dynamic get allowanceTarget => throw _privateConstructorUsedError;
  dynamic get sellTokenToEthRate => throw _privateConstructorUsedError;
  dynamic get buyTokenToEthRate => throw _privateConstructorUsedError;
  dynamic get to => throw _privateConstructorUsedError;
  dynamic get data => throw _privateConstructorUsedError;
  dynamic get decodedUniqueId => throw _privateConstructorUsedError;
  dynamic get guaranteedPrice => throw _privateConstructorUsedError;
  List<Order> get orders => throw _privateConstructorUsedError;
  Fees get fees => throw _privateConstructorUsedError;
  AuxiliaryChainData get auxiliaryChainData =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SwapDetailsQuoteCopyWith<SwapDetailsQuote> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapDetailsQuoteCopyWith<$Res> {
  factory $SwapDetailsQuoteCopyWith(
          SwapDetailsQuote value, $Res Function(SwapDetailsQuote) then) =
      _$SwapDetailsQuoteCopyWithImpl<$Res, SwapDetailsQuote>;
  @useResult
  $Res call(
      {dynamic chainId,
      dynamic price,
      dynamic grossPrice,
      dynamic estimatedPriceImpact,
      dynamic value,
      dynamic gasPrice,
      dynamic gas,
      dynamic estimatedGas,
      dynamic protocolFee,
      dynamic minimumProtocolFee,
      dynamic buyTokenAddress,
      dynamic buyAmount,
      dynamic grossBuyAmount,
      dynamic sellTokenAddress,
      dynamic sellAmount,
      dynamic grossSellAmount,
      List<Source> sources,
      dynamic allowanceTarget,
      dynamic sellTokenToEthRate,
      dynamic buyTokenToEthRate,
      dynamic to,
      dynamic data,
      dynamic decodedUniqueId,
      dynamic guaranteedPrice,
      List<Order> orders,
      Fees fees,
      AuxiliaryChainData auxiliaryChainData});

  $FeesCopyWith<$Res> get fees;
  $AuxiliaryChainDataCopyWith<$Res> get auxiliaryChainData;
}

/// @nodoc
class _$SwapDetailsQuoteCopyWithImpl<$Res, $Val extends SwapDetailsQuote>
    implements $SwapDetailsQuoteCopyWith<$Res> {
  _$SwapDetailsQuoteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainId = freezed,
    Object? price = freezed,
    Object? grossPrice = freezed,
    Object? estimatedPriceImpact = freezed,
    Object? value = freezed,
    Object? gasPrice = freezed,
    Object? gas = freezed,
    Object? estimatedGas = freezed,
    Object? protocolFee = freezed,
    Object? minimumProtocolFee = freezed,
    Object? buyTokenAddress = freezed,
    Object? buyAmount = freezed,
    Object? grossBuyAmount = freezed,
    Object? sellTokenAddress = freezed,
    Object? sellAmount = freezed,
    Object? grossSellAmount = freezed,
    Object? sources = null,
    Object? allowanceTarget = freezed,
    Object? sellTokenToEthRate = freezed,
    Object? buyTokenToEthRate = freezed,
    Object? to = freezed,
    Object? data = freezed,
    Object? decodedUniqueId = freezed,
    Object? guaranteedPrice = freezed,
    Object? orders = null,
    Object? fees = null,
    Object? auxiliaryChainData = null,
  }) {
    return _then(_value.copyWith(
      chainId: freezed == chainId
          ? _value.chainId
          : chainId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      price: freezed == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grossPrice: freezed == grossPrice
          ? _value.grossPrice
          : grossPrice // ignore: cast_nullable_to_non_nullable
              as dynamic,
      estimatedPriceImpact: freezed == estimatedPriceImpact
          ? _value.estimatedPriceImpact
          : estimatedPriceImpact // ignore: cast_nullable_to_non_nullable
              as dynamic,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
      gasPrice: freezed == gasPrice
          ? _value.gasPrice
          : gasPrice // ignore: cast_nullable_to_non_nullable
              as dynamic,
      gas: freezed == gas
          ? _value.gas
          : gas // ignore: cast_nullable_to_non_nullable
              as dynamic,
      estimatedGas: freezed == estimatedGas
          ? _value.estimatedGas
          : estimatedGas // ignore: cast_nullable_to_non_nullable
              as dynamic,
      protocolFee: freezed == protocolFee
          ? _value.protocolFee
          : protocolFee // ignore: cast_nullable_to_non_nullable
              as dynamic,
      minimumProtocolFee: freezed == minimumProtocolFee
          ? _value.minimumProtocolFee
          : minimumProtocolFee // ignore: cast_nullable_to_non_nullable
              as dynamic,
      buyTokenAddress: freezed == buyTokenAddress
          ? _value.buyTokenAddress
          : buyTokenAddress // ignore: cast_nullable_to_non_nullable
              as dynamic,
      buyAmount: freezed == buyAmount
          ? _value.buyAmount
          : buyAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grossBuyAmount: freezed == grossBuyAmount
          ? _value.grossBuyAmount
          : grossBuyAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sellTokenAddress: freezed == sellTokenAddress
          ? _value.sellTokenAddress
          : sellTokenAddress // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sellAmount: freezed == sellAmount
          ? _value.sellAmount
          : sellAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grossSellAmount: freezed == grossSellAmount
          ? _value.grossSellAmount
          : grossSellAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sources: null == sources
          ? _value.sources
          : sources // ignore: cast_nullable_to_non_nullable
              as List<Source>,
      allowanceTarget: freezed == allowanceTarget
          ? _value.allowanceTarget
          : allowanceTarget // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sellTokenToEthRate: freezed == sellTokenToEthRate
          ? _value.sellTokenToEthRate
          : sellTokenToEthRate // ignore: cast_nullable_to_non_nullable
              as dynamic,
      buyTokenToEthRate: freezed == buyTokenToEthRate
          ? _value.buyTokenToEthRate
          : buyTokenToEthRate // ignore: cast_nullable_to_non_nullable
              as dynamic,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as dynamic,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as dynamic,
      decodedUniqueId: freezed == decodedUniqueId
          ? _value.decodedUniqueId
          : decodedUniqueId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      guaranteedPrice: freezed == guaranteedPrice
          ? _value.guaranteedPrice
          : guaranteedPrice // ignore: cast_nullable_to_non_nullable
              as dynamic,
      orders: null == orders
          ? _value.orders
          : orders // ignore: cast_nullable_to_non_nullable
              as List<Order>,
      fees: null == fees
          ? _value.fees
          : fees // ignore: cast_nullable_to_non_nullable
              as Fees,
      auxiliaryChainData: null == auxiliaryChainData
          ? _value.auxiliaryChainData
          : auxiliaryChainData // ignore: cast_nullable_to_non_nullable
              as AuxiliaryChainData,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FeesCopyWith<$Res> get fees {
    return $FeesCopyWith<$Res>(_value.fees, (value) {
      return _then(_value.copyWith(fees: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AuxiliaryChainDataCopyWith<$Res> get auxiliaryChainData {
    return $AuxiliaryChainDataCopyWith<$Res>(_value.auxiliaryChainData,
        (value) {
      return _then(_value.copyWith(auxiliaryChainData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SwapDetailsQuoteImplCopyWith<$Res>
    implements $SwapDetailsQuoteCopyWith<$Res> {
  factory _$$SwapDetailsQuoteImplCopyWith(_$SwapDetailsQuoteImpl value,
          $Res Function(_$SwapDetailsQuoteImpl) then) =
      __$$SwapDetailsQuoteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic chainId,
      dynamic price,
      dynamic grossPrice,
      dynamic estimatedPriceImpact,
      dynamic value,
      dynamic gasPrice,
      dynamic gas,
      dynamic estimatedGas,
      dynamic protocolFee,
      dynamic minimumProtocolFee,
      dynamic buyTokenAddress,
      dynamic buyAmount,
      dynamic grossBuyAmount,
      dynamic sellTokenAddress,
      dynamic sellAmount,
      dynamic grossSellAmount,
      List<Source> sources,
      dynamic allowanceTarget,
      dynamic sellTokenToEthRate,
      dynamic buyTokenToEthRate,
      dynamic to,
      dynamic data,
      dynamic decodedUniqueId,
      dynamic guaranteedPrice,
      List<Order> orders,
      Fees fees,
      AuxiliaryChainData auxiliaryChainData});

  @override
  $FeesCopyWith<$Res> get fees;
  @override
  $AuxiliaryChainDataCopyWith<$Res> get auxiliaryChainData;
}

/// @nodoc
class __$$SwapDetailsQuoteImplCopyWithImpl<$Res>
    extends _$SwapDetailsQuoteCopyWithImpl<$Res, _$SwapDetailsQuoteImpl>
    implements _$$SwapDetailsQuoteImplCopyWith<$Res> {
  __$$SwapDetailsQuoteImplCopyWithImpl(_$SwapDetailsQuoteImpl _value,
      $Res Function(_$SwapDetailsQuoteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainId = freezed,
    Object? price = freezed,
    Object? grossPrice = freezed,
    Object? estimatedPriceImpact = freezed,
    Object? value = freezed,
    Object? gasPrice = freezed,
    Object? gas = freezed,
    Object? estimatedGas = freezed,
    Object? protocolFee = freezed,
    Object? minimumProtocolFee = freezed,
    Object? buyTokenAddress = freezed,
    Object? buyAmount = freezed,
    Object? grossBuyAmount = freezed,
    Object? sellTokenAddress = freezed,
    Object? sellAmount = freezed,
    Object? grossSellAmount = freezed,
    Object? sources = null,
    Object? allowanceTarget = freezed,
    Object? sellTokenToEthRate = freezed,
    Object? buyTokenToEthRate = freezed,
    Object? to = freezed,
    Object? data = freezed,
    Object? decodedUniqueId = freezed,
    Object? guaranteedPrice = freezed,
    Object? orders = null,
    Object? fees = null,
    Object? auxiliaryChainData = null,
  }) {
    return _then(_$SwapDetailsQuoteImpl(
      chainId: freezed == chainId ? _value.chainId! : chainId,
      price: freezed == price ? _value.price! : price,
      grossPrice: freezed == grossPrice ? _value.grossPrice! : grossPrice,
      estimatedPriceImpact: freezed == estimatedPriceImpact
          ? _value.estimatedPriceImpact!
          : estimatedPriceImpact,
      value: freezed == value ? _value.value! : value,
      gasPrice: freezed == gasPrice ? _value.gasPrice! : gasPrice,
      gas: freezed == gas ? _value.gas! : gas,
      estimatedGas:
          freezed == estimatedGas ? _value.estimatedGas! : estimatedGas,
      protocolFee: freezed == protocolFee ? _value.protocolFee! : protocolFee,
      minimumProtocolFee: freezed == minimumProtocolFee
          ? _value.minimumProtocolFee!
          : minimumProtocolFee,
      buyTokenAddress: freezed == buyTokenAddress
          ? _value.buyTokenAddress!
          : buyTokenAddress,
      buyAmount: freezed == buyAmount ? _value.buyAmount! : buyAmount,
      grossBuyAmount:
          freezed == grossBuyAmount ? _value.grossBuyAmount! : grossBuyAmount,
      sellTokenAddress: freezed == sellTokenAddress
          ? _value.sellTokenAddress!
          : sellTokenAddress,
      sellAmount: freezed == sellAmount ? _value.sellAmount! : sellAmount,
      grossSellAmount: freezed == grossSellAmount
          ? _value.grossSellAmount!
          : grossSellAmount,
      sources: null == sources
          ? _value._sources
          : sources // ignore: cast_nullable_to_non_nullable
              as List<Source>,
      allowanceTarget: freezed == allowanceTarget
          ? _value.allowanceTarget!
          : allowanceTarget,
      sellTokenToEthRate: freezed == sellTokenToEthRate
          ? _value.sellTokenToEthRate!
          : sellTokenToEthRate,
      buyTokenToEthRate: freezed == buyTokenToEthRate
          ? _value.buyTokenToEthRate!
          : buyTokenToEthRate,
      to: freezed == to ? _value.to! : to,
      data: freezed == data ? _value.data! : data,
      decodedUniqueId: freezed == decodedUniqueId
          ? _value.decodedUniqueId!
          : decodedUniqueId,
      guaranteedPrice: freezed == guaranteedPrice
          ? _value.guaranteedPrice!
          : guaranteedPrice,
      orders: null == orders
          ? _value._orders
          : orders // ignore: cast_nullable_to_non_nullable
              as List<Order>,
      fees: null == fees
          ? _value.fees
          : fees // ignore: cast_nullable_to_non_nullable
              as Fees,
      auxiliaryChainData: null == auxiliaryChainData
          ? _value.auxiliaryChainData
          : auxiliaryChainData // ignore: cast_nullable_to_non_nullable
              as AuxiliaryChainData,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SwapDetailsQuoteImpl implements _SwapDetailsQuote {
  const _$SwapDetailsQuoteImpl(
      {this.chainId = 0,
      this.price = "",
      this.grossPrice = "",
      this.estimatedPriceImpact = "",
      this.value = "",
      this.gasPrice = "",
      this.gas = "",
      this.estimatedGas = "",
      this.protocolFee = "",
      this.minimumProtocolFee = "",
      this.buyTokenAddress = "",
      this.buyAmount = "",
      this.grossBuyAmount = "",
      this.sellTokenAddress = "",
      this.sellAmount = "",
      this.grossSellAmount = "",
      required final List<Source> sources,
      this.allowanceTarget = "",
      this.sellTokenToEthRate = "",
      this.buyTokenToEthRate = "",
      this.to = "",
      this.data = "",
      this.decodedUniqueId = "",
      this.guaranteedPrice = "",
      required final List<Order> orders,
      required this.fees,
      required this.auxiliaryChainData})
      : _sources = sources,
        _orders = orders;

  factory _$SwapDetailsQuoteImpl.fromJson(Map<String, dynamic> json) =>
      _$$SwapDetailsQuoteImplFromJson(json);

  @override
  @JsonKey()
  final dynamic chainId;
  @override
  @JsonKey()
  final dynamic price;
  @override
  @JsonKey()
  final dynamic grossPrice;
  @override
  @JsonKey()
  final dynamic estimatedPriceImpact;
  @override
  @JsonKey()
  final dynamic value;
  @override
  @JsonKey()
  final dynamic gasPrice;
  @override
  @JsonKey()
  final dynamic gas;
  @override
  @JsonKey()
  final dynamic estimatedGas;
  @override
  @JsonKey()
  final dynamic protocolFee;
  @override
  @JsonKey()
  final dynamic minimumProtocolFee;
  @override
  @JsonKey()
  final dynamic buyTokenAddress;
  @override
  @JsonKey()
  final dynamic buyAmount;
  @override
  @JsonKey()
  final dynamic grossBuyAmount;
  @override
  @JsonKey()
  final dynamic sellTokenAddress;
  @override
  @JsonKey()
  final dynamic sellAmount;
  @override
  @JsonKey()
  final dynamic grossSellAmount;
  final List<Source> _sources;
  @override
  List<Source> get sources {
    if (_sources is EqualUnmodifiableListView) return _sources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sources);
  }

  @override
  @JsonKey()
  final dynamic allowanceTarget;
  @override
  @JsonKey()
  final dynamic sellTokenToEthRate;
  @override
  @JsonKey()
  final dynamic buyTokenToEthRate;
  @override
  @JsonKey()
  final dynamic to;
  @override
  @JsonKey()
  final dynamic data;
  @override
  @JsonKey()
  final dynamic decodedUniqueId;
  @override
  @JsonKey()
  final dynamic guaranteedPrice;
  final List<Order> _orders;
  @override
  List<Order> get orders {
    if (_orders is EqualUnmodifiableListView) return _orders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_orders);
  }

  @override
  final Fees fees;
  @override
  final AuxiliaryChainData auxiliaryChainData;

  @override
  String toString() {
    return 'SwapDetailsQuote(chainId: $chainId, price: $price, grossPrice: $grossPrice, estimatedPriceImpact: $estimatedPriceImpact, value: $value, gasPrice: $gasPrice, gas: $gas, estimatedGas: $estimatedGas, protocolFee: $protocolFee, minimumProtocolFee: $minimumProtocolFee, buyTokenAddress: $buyTokenAddress, buyAmount: $buyAmount, grossBuyAmount: $grossBuyAmount, sellTokenAddress: $sellTokenAddress, sellAmount: $sellAmount, grossSellAmount: $grossSellAmount, sources: $sources, allowanceTarget: $allowanceTarget, sellTokenToEthRate: $sellTokenToEthRate, buyTokenToEthRate: $buyTokenToEthRate, to: $to, data: $data, decodedUniqueId: $decodedUniqueId, guaranteedPrice: $guaranteedPrice, orders: $orders, fees: $fees, auxiliaryChainData: $auxiliaryChainData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapDetailsQuoteImpl &&
            const DeepCollectionEquality().equals(other.chainId, chainId) &&
            const DeepCollectionEquality().equals(other.price, price) &&
            const DeepCollectionEquality()
                .equals(other.grossPrice, grossPrice) &&
            const DeepCollectionEquality()
                .equals(other.estimatedPriceImpact, estimatedPriceImpact) &&
            const DeepCollectionEquality().equals(other.value, value) &&
            const DeepCollectionEquality().equals(other.gasPrice, gasPrice) &&
            const DeepCollectionEquality().equals(other.gas, gas) &&
            const DeepCollectionEquality()
                .equals(other.estimatedGas, estimatedGas) &&
            const DeepCollectionEquality()
                .equals(other.protocolFee, protocolFee) &&
            const DeepCollectionEquality()
                .equals(other.minimumProtocolFee, minimumProtocolFee) &&
            const DeepCollectionEquality()
                .equals(other.buyTokenAddress, buyTokenAddress) &&
            const DeepCollectionEquality().equals(other.buyAmount, buyAmount) &&
            const DeepCollectionEquality()
                .equals(other.grossBuyAmount, grossBuyAmount) &&
            const DeepCollectionEquality()
                .equals(other.sellTokenAddress, sellTokenAddress) &&
            const DeepCollectionEquality()
                .equals(other.sellAmount, sellAmount) &&
            const DeepCollectionEquality()
                .equals(other.grossSellAmount, grossSellAmount) &&
            const DeepCollectionEquality().equals(other._sources, _sources) &&
            const DeepCollectionEquality()
                .equals(other.allowanceTarget, allowanceTarget) &&
            const DeepCollectionEquality()
                .equals(other.sellTokenToEthRate, sellTokenToEthRate) &&
            const DeepCollectionEquality()
                .equals(other.buyTokenToEthRate, buyTokenToEthRate) &&
            const DeepCollectionEquality().equals(other.to, to) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            const DeepCollectionEquality()
                .equals(other.decodedUniqueId, decodedUniqueId) &&
            const DeepCollectionEquality()
                .equals(other.guaranteedPrice, guaranteedPrice) &&
            const DeepCollectionEquality().equals(other._orders, _orders) &&
            (identical(other.fees, fees) || other.fees == fees) &&
            (identical(other.auxiliaryChainData, auxiliaryChainData) ||
                other.auxiliaryChainData == auxiliaryChainData));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        const DeepCollectionEquality().hash(chainId),
        const DeepCollectionEquality().hash(price),
        const DeepCollectionEquality().hash(grossPrice),
        const DeepCollectionEquality().hash(estimatedPriceImpact),
        const DeepCollectionEquality().hash(value),
        const DeepCollectionEquality().hash(gasPrice),
        const DeepCollectionEquality().hash(gas),
        const DeepCollectionEquality().hash(estimatedGas),
        const DeepCollectionEquality().hash(protocolFee),
        const DeepCollectionEquality().hash(minimumProtocolFee),
        const DeepCollectionEquality().hash(buyTokenAddress),
        const DeepCollectionEquality().hash(buyAmount),
        const DeepCollectionEquality().hash(grossBuyAmount),
        const DeepCollectionEquality().hash(sellTokenAddress),
        const DeepCollectionEquality().hash(sellAmount),
        const DeepCollectionEquality().hash(grossSellAmount),
        const DeepCollectionEquality().hash(_sources),
        const DeepCollectionEquality().hash(allowanceTarget),
        const DeepCollectionEquality().hash(sellTokenToEthRate),
        const DeepCollectionEquality().hash(buyTokenToEthRate),
        const DeepCollectionEquality().hash(to),
        const DeepCollectionEquality().hash(data),
        const DeepCollectionEquality().hash(decodedUniqueId),
        const DeepCollectionEquality().hash(guaranteedPrice),
        const DeepCollectionEquality().hash(_orders),
        fees,
        auxiliaryChainData
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SwapDetailsQuoteImplCopyWith<_$SwapDetailsQuoteImpl> get copyWith =>
      __$$SwapDetailsQuoteImplCopyWithImpl<_$SwapDetailsQuoteImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SwapDetailsQuoteImplToJson(
      this,
    );
  }
}

abstract class _SwapDetailsQuote implements SwapDetailsQuote {
  const factory _SwapDetailsQuote(
          {final dynamic chainId,
          final dynamic price,
          final dynamic grossPrice,
          final dynamic estimatedPriceImpact,
          final dynamic value,
          final dynamic gasPrice,
          final dynamic gas,
          final dynamic estimatedGas,
          final dynamic protocolFee,
          final dynamic minimumProtocolFee,
          final dynamic buyTokenAddress,
          final dynamic buyAmount,
          final dynamic grossBuyAmount,
          final dynamic sellTokenAddress,
          final dynamic sellAmount,
          final dynamic grossSellAmount,
          required final List<Source> sources,
          final dynamic allowanceTarget,
          final dynamic sellTokenToEthRate,
          final dynamic buyTokenToEthRate,
          final dynamic to,
          final dynamic data,
          final dynamic decodedUniqueId,
          final dynamic guaranteedPrice,
          required final List<Order> orders,
          required final Fees fees,
          required final AuxiliaryChainData auxiliaryChainData}) =
      _$SwapDetailsQuoteImpl;

  factory _SwapDetailsQuote.fromJson(Map<String, dynamic> json) =
      _$SwapDetailsQuoteImpl.fromJson;

  @override
  dynamic get chainId;
  @override
  dynamic get price;
  @override
  dynamic get grossPrice;
  @override
  dynamic get estimatedPriceImpact;
  @override
  dynamic get value;
  @override
  dynamic get gasPrice;
  @override
  dynamic get gas;
  @override
  dynamic get estimatedGas;
  @override
  dynamic get protocolFee;
  @override
  dynamic get minimumProtocolFee;
  @override
  dynamic get buyTokenAddress;
  @override
  dynamic get buyAmount;
  @override
  dynamic get grossBuyAmount;
  @override
  dynamic get sellTokenAddress;
  @override
  dynamic get sellAmount;
  @override
  dynamic get grossSellAmount;
  @override
  List<Source> get sources;
  @override
  dynamic get allowanceTarget;
  @override
  dynamic get sellTokenToEthRate;
  @override
  dynamic get buyTokenToEthRate;
  @override
  dynamic get to;
  @override
  dynamic get data;
  @override
  dynamic get decodedUniqueId;
  @override
  dynamic get guaranteedPrice;
  @override
  List<Order> get orders;
  @override
  Fees get fees;
  @override
  AuxiliaryChainData get auxiliaryChainData;
  @override
  @JsonKey(ignore: true)
  _$$SwapDetailsQuoteImplCopyWith<_$SwapDetailsQuoteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AuxiliaryChainData _$AuxiliaryChainDataFromJson(Map<String, dynamic> json) {
  return _AuxiliaryChainData.fromJson(json);
}

/// @nodoc
mixin _$AuxiliaryChainData {
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuxiliaryChainDataCopyWith<$Res> {
  factory $AuxiliaryChainDataCopyWith(
          AuxiliaryChainData value, $Res Function(AuxiliaryChainData) then) =
      _$AuxiliaryChainDataCopyWithImpl<$Res, AuxiliaryChainData>;
}

/// @nodoc
class _$AuxiliaryChainDataCopyWithImpl<$Res, $Val extends AuxiliaryChainData>
    implements $AuxiliaryChainDataCopyWith<$Res> {
  _$AuxiliaryChainDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AuxiliaryChainDataImplCopyWith<$Res> {
  factory _$$AuxiliaryChainDataImplCopyWith(_$AuxiliaryChainDataImpl value,
          $Res Function(_$AuxiliaryChainDataImpl) then) =
      __$$AuxiliaryChainDataImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AuxiliaryChainDataImplCopyWithImpl<$Res>
    extends _$AuxiliaryChainDataCopyWithImpl<$Res, _$AuxiliaryChainDataImpl>
    implements _$$AuxiliaryChainDataImplCopyWith<$Res> {
  __$$AuxiliaryChainDataImplCopyWithImpl(_$AuxiliaryChainDataImpl _value,
      $Res Function(_$AuxiliaryChainDataImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$AuxiliaryChainDataImpl implements _AuxiliaryChainData {
  const _$AuxiliaryChainDataImpl();

  factory _$AuxiliaryChainDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuxiliaryChainDataImplFromJson(json);

  @override
  String toString() {
    return 'AuxiliaryChainData()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AuxiliaryChainDataImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  Map<String, dynamic> toJson() {
    return _$$AuxiliaryChainDataImplToJson(
      this,
    );
  }
}

abstract class _AuxiliaryChainData implements AuxiliaryChainData {
  const factory _AuxiliaryChainData() = _$AuxiliaryChainDataImpl;

  factory _AuxiliaryChainData.fromJson(Map<String, dynamic> json) =
      _$AuxiliaryChainDataImpl.fromJson;
}

Fees _$FeesFromJson(Map<String, dynamic> json) {
  return _Fees.fromJson(json);
}

/// @nodoc
mixin _$Fees {
  ZeroExFee get zeroExFee => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FeesCopyWith<Fees> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeesCopyWith<$Res> {
  factory $FeesCopyWith(Fees value, $Res Function(Fees) then) =
      _$FeesCopyWithImpl<$Res, Fees>;
  @useResult
  $Res call({ZeroExFee zeroExFee});

  $ZeroExFeeCopyWith<$Res> get zeroExFee;
}

/// @nodoc
class _$FeesCopyWithImpl<$Res, $Val extends Fees>
    implements $FeesCopyWith<$Res> {
  _$FeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? zeroExFee = null,
  }) {
    return _then(_value.copyWith(
      zeroExFee: null == zeroExFee
          ? _value.zeroExFee
          : zeroExFee // ignore: cast_nullable_to_non_nullable
              as ZeroExFee,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ZeroExFeeCopyWith<$Res> get zeroExFee {
    return $ZeroExFeeCopyWith<$Res>(_value.zeroExFee, (value) {
      return _then(_value.copyWith(zeroExFee: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FeesImplCopyWith<$Res> implements $FeesCopyWith<$Res> {
  factory _$$FeesImplCopyWith(
          _$FeesImpl value, $Res Function(_$FeesImpl) then) =
      __$$FeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ZeroExFee zeroExFee});

  @override
  $ZeroExFeeCopyWith<$Res> get zeroExFee;
}

/// @nodoc
class __$$FeesImplCopyWithImpl<$Res>
    extends _$FeesCopyWithImpl<$Res, _$FeesImpl>
    implements _$$FeesImplCopyWith<$Res> {
  __$$FeesImplCopyWithImpl(_$FeesImpl _value, $Res Function(_$FeesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? zeroExFee = null,
  }) {
    return _then(_$FeesImpl(
      zeroExFee: null == zeroExFee
          ? _value.zeroExFee
          : zeroExFee // ignore: cast_nullable_to_non_nullable
              as ZeroExFee,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FeesImpl implements _Fees {
  const _$FeesImpl({required this.zeroExFee});

  factory _$FeesImpl.fromJson(Map<String, dynamic> json) =>
      _$$FeesImplFromJson(json);

  @override
  final ZeroExFee zeroExFee;

  @override
  String toString() {
    return 'Fees(zeroExFee: $zeroExFee)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeesImpl &&
            (identical(other.zeroExFee, zeroExFee) ||
                other.zeroExFee == zeroExFee));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, zeroExFee);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FeesImplCopyWith<_$FeesImpl> get copyWith =>
      __$$FeesImplCopyWithImpl<_$FeesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FeesImplToJson(
      this,
    );
  }
}

abstract class _Fees implements Fees {
  const factory _Fees({required final ZeroExFee zeroExFee}) = _$FeesImpl;

  factory _Fees.fromJson(Map<String, dynamic> json) = _$FeesImpl.fromJson;

  @override
  ZeroExFee get zeroExFee;
  @override
  @JsonKey(ignore: true)
  _$$FeesImplCopyWith<_$FeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ZeroExFee _$ZeroExFeeFromJson(Map<String, dynamic> json) {
  return _ZeroExFee.fromJson(json);
}

/// @nodoc
mixin _$ZeroExFee {
  dynamic get feeType => throw _privateConstructorUsedError;
  dynamic get feeToken => throw _privateConstructorUsedError;
  dynamic get feeAmount => throw _privateConstructorUsedError;
  dynamic get billingType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ZeroExFeeCopyWith<ZeroExFee> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ZeroExFeeCopyWith<$Res> {
  factory $ZeroExFeeCopyWith(ZeroExFee value, $Res Function(ZeroExFee) then) =
      _$ZeroExFeeCopyWithImpl<$Res, ZeroExFee>;
  @useResult
  $Res call(
      {dynamic feeType,
      dynamic feeToken,
      dynamic feeAmount,
      dynamic billingType});
}

/// @nodoc
class _$ZeroExFeeCopyWithImpl<$Res, $Val extends ZeroExFee>
    implements $ZeroExFeeCopyWith<$Res> {
  _$ZeroExFeeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeType = freezed,
    Object? feeToken = freezed,
    Object? feeAmount = freezed,
    Object? billingType = freezed,
  }) {
    return _then(_value.copyWith(
      feeType: freezed == feeType
          ? _value.feeType
          : feeType // ignore: cast_nullable_to_non_nullable
              as dynamic,
      feeToken: freezed == feeToken
          ? _value.feeToken
          : feeToken // ignore: cast_nullable_to_non_nullable
              as dynamic,
      feeAmount: freezed == feeAmount
          ? _value.feeAmount
          : feeAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      billingType: freezed == billingType
          ? _value.billingType
          : billingType // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ZeroExFeeImplCopyWith<$Res>
    implements $ZeroExFeeCopyWith<$Res> {
  factory _$$ZeroExFeeImplCopyWith(
          _$ZeroExFeeImpl value, $Res Function(_$ZeroExFeeImpl) then) =
      __$$ZeroExFeeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic feeType,
      dynamic feeToken,
      dynamic feeAmount,
      dynamic billingType});
}

/// @nodoc
class __$$ZeroExFeeImplCopyWithImpl<$Res>
    extends _$ZeroExFeeCopyWithImpl<$Res, _$ZeroExFeeImpl>
    implements _$$ZeroExFeeImplCopyWith<$Res> {
  __$$ZeroExFeeImplCopyWithImpl(
      _$ZeroExFeeImpl _value, $Res Function(_$ZeroExFeeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeType = freezed,
    Object? feeToken = freezed,
    Object? feeAmount = freezed,
    Object? billingType = freezed,
  }) {
    return _then(_$ZeroExFeeImpl(
      feeType: freezed == feeType ? _value.feeType! : feeType,
      feeToken: freezed == feeToken ? _value.feeToken! : feeToken,
      feeAmount: freezed == feeAmount ? _value.feeAmount! : feeAmount,
      billingType: freezed == billingType ? _value.billingType! : billingType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ZeroExFeeImpl implements _ZeroExFee {
  const _$ZeroExFeeImpl(
      {this.feeType = "",
      this.feeToken = "",
      this.feeAmount = "",
      this.billingType = ""});

  factory _$ZeroExFeeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ZeroExFeeImplFromJson(json);

  @override
  @JsonKey()
  final dynamic feeType;
  @override
  @JsonKey()
  final dynamic feeToken;
  @override
  @JsonKey()
  final dynamic feeAmount;
  @override
  @JsonKey()
  final dynamic billingType;

  @override
  String toString() {
    return 'ZeroExFee(feeType: $feeType, feeToken: $feeToken, feeAmount: $feeAmount, billingType: $billingType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ZeroExFeeImpl &&
            const DeepCollectionEquality().equals(other.feeType, feeType) &&
            const DeepCollectionEquality().equals(other.feeToken, feeToken) &&
            const DeepCollectionEquality().equals(other.feeAmount, feeAmount) &&
            const DeepCollectionEquality()
                .equals(other.billingType, billingType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(feeType),
      const DeepCollectionEquality().hash(feeToken),
      const DeepCollectionEquality().hash(feeAmount),
      const DeepCollectionEquality().hash(billingType));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ZeroExFeeImplCopyWith<_$ZeroExFeeImpl> get copyWith =>
      __$$ZeroExFeeImplCopyWithImpl<_$ZeroExFeeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ZeroExFeeImplToJson(
      this,
    );
  }
}

abstract class _ZeroExFee implements ZeroExFee {
  const factory _ZeroExFee(
      {final dynamic feeType,
      final dynamic feeToken,
      final dynamic feeAmount,
      final dynamic billingType}) = _$ZeroExFeeImpl;

  factory _ZeroExFee.fromJson(Map<String, dynamic> json) =
      _$ZeroExFeeImpl.fromJson;

  @override
  dynamic get feeType;
  @override
  dynamic get feeToken;
  @override
  dynamic get feeAmount;
  @override
  dynamic get billingType;
  @override
  @JsonKey(ignore: true)
  _$$ZeroExFeeImplCopyWith<_$ZeroExFeeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Order _$OrderFromJson(Map<String, dynamic> json) {
  return _Order.fromJson(json);
}

/// @nodoc
mixin _$Order {
  dynamic get type => throw _privateConstructorUsedError;
  dynamic get source => throw _privateConstructorUsedError;
  dynamic get makerToken => throw _privateConstructorUsedError;
  dynamic get takerToken => throw _privateConstructorUsedError;
  dynamic get makerAmount => throw _privateConstructorUsedError;
  dynamic get takerAmount => throw _privateConstructorUsedError;
  FillData get fillData => throw _privateConstructorUsedError;
  Fill get fill => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OrderCopyWith<Order> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderCopyWith<$Res> {
  factory $OrderCopyWith(Order value, $Res Function(Order) then) =
      _$OrderCopyWithImpl<$Res, Order>;
  @useResult
  $Res call(
      {dynamic type,
      dynamic source,
      dynamic makerToken,
      dynamic takerToken,
      dynamic makerAmount,
      dynamic takerAmount,
      FillData fillData,
      Fill fill});

  $FillDataCopyWith<$Res> get fillData;
  $FillCopyWith<$Res> get fill;
}

/// @nodoc
class _$OrderCopyWithImpl<$Res, $Val extends Order>
    implements $OrderCopyWith<$Res> {
  _$OrderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? source = freezed,
    Object? makerToken = freezed,
    Object? takerToken = freezed,
    Object? makerAmount = freezed,
    Object? takerAmount = freezed,
    Object? fillData = null,
    Object? fill = null,
  }) {
    return _then(_value.copyWith(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as dynamic,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as dynamic,
      makerToken: freezed == makerToken
          ? _value.makerToken
          : makerToken // ignore: cast_nullable_to_non_nullable
              as dynamic,
      takerToken: freezed == takerToken
          ? _value.takerToken
          : takerToken // ignore: cast_nullable_to_non_nullable
              as dynamic,
      makerAmount: freezed == makerAmount
          ? _value.makerAmount
          : makerAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      takerAmount: freezed == takerAmount
          ? _value.takerAmount
          : takerAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      fillData: null == fillData
          ? _value.fillData
          : fillData // ignore: cast_nullable_to_non_nullable
              as FillData,
      fill: null == fill
          ? _value.fill
          : fill // ignore: cast_nullable_to_non_nullable
              as Fill,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FillDataCopyWith<$Res> get fillData {
    return $FillDataCopyWith<$Res>(_value.fillData, (value) {
      return _then(_value.copyWith(fillData: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FillCopyWith<$Res> get fill {
    return $FillCopyWith<$Res>(_value.fill, (value) {
      return _then(_value.copyWith(fill: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OrderImplCopyWith<$Res> implements $OrderCopyWith<$Res> {
  factory _$$OrderImplCopyWith(
          _$OrderImpl value, $Res Function(_$OrderImpl) then) =
      __$$OrderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic type,
      dynamic source,
      dynamic makerToken,
      dynamic takerToken,
      dynamic makerAmount,
      dynamic takerAmount,
      FillData fillData,
      Fill fill});

  @override
  $FillDataCopyWith<$Res> get fillData;
  @override
  $FillCopyWith<$Res> get fill;
}

/// @nodoc
class __$$OrderImplCopyWithImpl<$Res>
    extends _$OrderCopyWithImpl<$Res, _$OrderImpl>
    implements _$$OrderImplCopyWith<$Res> {
  __$$OrderImplCopyWithImpl(
      _$OrderImpl _value, $Res Function(_$OrderImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? source = freezed,
    Object? makerToken = freezed,
    Object? takerToken = freezed,
    Object? makerAmount = freezed,
    Object? takerAmount = freezed,
    Object? fillData = null,
    Object? fill = null,
  }) {
    return _then(_$OrderImpl(
      type: freezed == type ? _value.type! : type,
      source: freezed == source ? _value.source! : source,
      makerToken: freezed == makerToken ? _value.makerToken! : makerToken,
      takerToken: freezed == takerToken ? _value.takerToken! : takerToken,
      makerAmount: freezed == makerAmount ? _value.makerAmount! : makerAmount,
      takerAmount: freezed == takerAmount ? _value.takerAmount! : takerAmount,
      fillData: null == fillData
          ? _value.fillData
          : fillData // ignore: cast_nullable_to_non_nullable
              as FillData,
      fill: null == fill
          ? _value.fill
          : fill // ignore: cast_nullable_to_non_nullable
              as Fill,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OrderImpl implements _Order {
  const _$OrderImpl(
      {this.type = 0,
      this.source = "",
      this.makerToken = "",
      this.takerToken = "",
      this.makerAmount = "",
      this.takerAmount = "",
      required this.fillData,
      required this.fill});

  factory _$OrderImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrderImplFromJson(json);

  @override
  @JsonKey()
  final dynamic type;
  @override
  @JsonKey()
  final dynamic source;
  @override
  @JsonKey()
  final dynamic makerToken;
  @override
  @JsonKey()
  final dynamic takerToken;
  @override
  @JsonKey()
  final dynamic makerAmount;
  @override
  @JsonKey()
  final dynamic takerAmount;
  @override
  final FillData fillData;
  @override
  final Fill fill;

  @override
  String toString() {
    return 'Order(type: $type, source: $source, makerToken: $makerToken, takerToken: $takerToken, makerAmount: $makerAmount, takerAmount: $takerAmount, fillData: $fillData, fill: $fill)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrderImpl &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.source, source) &&
            const DeepCollectionEquality()
                .equals(other.makerToken, makerToken) &&
            const DeepCollectionEquality()
                .equals(other.takerToken, takerToken) &&
            const DeepCollectionEquality()
                .equals(other.makerAmount, makerAmount) &&
            const DeepCollectionEquality()
                .equals(other.takerAmount, takerAmount) &&
            (identical(other.fillData, fillData) ||
                other.fillData == fillData) &&
            (identical(other.fill, fill) || other.fill == fill));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(source),
      const DeepCollectionEquality().hash(makerToken),
      const DeepCollectionEquality().hash(takerToken),
      const DeepCollectionEquality().hash(makerAmount),
      const DeepCollectionEquality().hash(takerAmount),
      fillData,
      fill);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OrderImplCopyWith<_$OrderImpl> get copyWith =>
      __$$OrderImplCopyWithImpl<_$OrderImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OrderImplToJson(
      this,
    );
  }
}

abstract class _Order implements Order {
  const factory _Order(
      {final dynamic type,
      final dynamic source,
      final dynamic makerToken,
      final dynamic takerToken,
      final dynamic makerAmount,
      final dynamic takerAmount,
      required final FillData fillData,
      required final Fill fill}) = _$OrderImpl;

  factory _Order.fromJson(Map<String, dynamic> json) = _$OrderImpl.fromJson;

  @override
  dynamic get type;
  @override
  dynamic get source;
  @override
  dynamic get makerToken;
  @override
  dynamic get takerToken;
  @override
  dynamic get makerAmount;
  @override
  dynamic get takerAmount;
  @override
  FillData get fillData;
  @override
  Fill get fill;
  @override
  @JsonKey(ignore: true)
  _$$OrderImplCopyWith<_$OrderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Fill _$FillFromJson(Map<String, dynamic> json) {
  return _Fill.fromJson(json);
}

/// @nodoc
mixin _$Fill {
  dynamic get input => throw _privateConstructorUsedError;
  dynamic get output => throw _privateConstructorUsedError;
  dynamic get adjustedOutput => throw _privateConstructorUsedError;
  dynamic get gas => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FillCopyWith<Fill> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FillCopyWith<$Res> {
  factory $FillCopyWith(Fill value, $Res Function(Fill) then) =
      _$FillCopyWithImpl<$Res, Fill>;
  @useResult
  $Res call(
      {dynamic input, dynamic output, dynamic adjustedOutput, dynamic gas});
}

/// @nodoc
class _$FillCopyWithImpl<$Res, $Val extends Fill>
    implements $FillCopyWith<$Res> {
  _$FillCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = freezed,
    Object? output = freezed,
    Object? adjustedOutput = freezed,
    Object? gas = freezed,
  }) {
    return _then(_value.copyWith(
      input: freezed == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as dynamic,
      output: freezed == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as dynamic,
      adjustedOutput: freezed == adjustedOutput
          ? _value.adjustedOutput
          : adjustedOutput // ignore: cast_nullable_to_non_nullable
              as dynamic,
      gas: freezed == gas
          ? _value.gas
          : gas // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FillImplCopyWith<$Res> implements $FillCopyWith<$Res> {
  factory _$$FillImplCopyWith(
          _$FillImpl value, $Res Function(_$FillImpl) then) =
      __$$FillImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic input, dynamic output, dynamic adjustedOutput, dynamic gas});
}

/// @nodoc
class __$$FillImplCopyWithImpl<$Res>
    extends _$FillCopyWithImpl<$Res, _$FillImpl>
    implements _$$FillImplCopyWith<$Res> {
  __$$FillImplCopyWithImpl(_$FillImpl _value, $Res Function(_$FillImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = freezed,
    Object? output = freezed,
    Object? adjustedOutput = freezed,
    Object? gas = freezed,
  }) {
    return _then(_$FillImpl(
      input: freezed == input ? _value.input! : input,
      output: freezed == output ? _value.output! : output,
      adjustedOutput:
          freezed == adjustedOutput ? _value.adjustedOutput! : adjustedOutput,
      gas: freezed == gas ? _value.gas! : gas,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FillImpl implements _Fill {
  const _$FillImpl(
      {this.input = "",
      this.output = "",
      this.adjustedOutput = "",
      this.gas = 0});

  factory _$FillImpl.fromJson(Map<String, dynamic> json) =>
      _$$FillImplFromJson(json);

  @override
  @JsonKey()
  final dynamic input;
  @override
  @JsonKey()
  final dynamic output;
  @override
  @JsonKey()
  final dynamic adjustedOutput;
  @override
  @JsonKey()
  final dynamic gas;

  @override
  String toString() {
    return 'Fill(input: $input, output: $output, adjustedOutput: $adjustedOutput, gas: $gas)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FillImpl &&
            const DeepCollectionEquality().equals(other.input, input) &&
            const DeepCollectionEquality().equals(other.output, output) &&
            const DeepCollectionEquality()
                .equals(other.adjustedOutput, adjustedOutput) &&
            const DeepCollectionEquality().equals(other.gas, gas));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(input),
      const DeepCollectionEquality().hash(output),
      const DeepCollectionEquality().hash(adjustedOutput),
      const DeepCollectionEquality().hash(gas));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FillImplCopyWith<_$FillImpl> get copyWith =>
      __$$FillImplCopyWithImpl<_$FillImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FillImplToJson(
      this,
    );
  }
}

abstract class _Fill implements Fill {
  const factory _Fill(
      {final dynamic input,
      final dynamic output,
      final dynamic adjustedOutput,
      final dynamic gas}) = _$FillImpl;

  factory _Fill.fromJson(Map<String, dynamic> json) = _$FillImpl.fromJson;

  @override
  dynamic get input;
  @override
  dynamic get output;
  @override
  dynamic get adjustedOutput;
  @override
  dynamic get gas;
  @override
  @JsonKey(ignore: true)
  _$$FillImplCopyWith<_$FillImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

FillData _$FillDataFromJson(Map<String, dynamic> json) {
  return _FillData.fromJson(json);
}

/// @nodoc
mixin _$FillData {
  List<String> get tokenAddressPath => throw _privateConstructorUsedError;
  dynamic get router => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FillDataCopyWith<FillData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FillDataCopyWith<$Res> {
  factory $FillDataCopyWith(FillData value, $Res Function(FillData) then) =
      _$FillDataCopyWithImpl<$Res, FillData>;
  @useResult
  $Res call({List<String> tokenAddressPath, dynamic router});
}

/// @nodoc
class _$FillDataCopyWithImpl<$Res, $Val extends FillData>
    implements $FillDataCopyWith<$Res> {
  _$FillDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokenAddressPath = null,
    Object? router = freezed,
  }) {
    return _then(_value.copyWith(
      tokenAddressPath: null == tokenAddressPath
          ? _value.tokenAddressPath
          : tokenAddressPath // ignore: cast_nullable_to_non_nullable
              as List<String>,
      router: freezed == router
          ? _value.router
          : router // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FillDataImplCopyWith<$Res>
    implements $FillDataCopyWith<$Res> {
  factory _$$FillDataImplCopyWith(
          _$FillDataImpl value, $Res Function(_$FillDataImpl) then) =
      __$$FillDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> tokenAddressPath, dynamic router});
}

/// @nodoc
class __$$FillDataImplCopyWithImpl<$Res>
    extends _$FillDataCopyWithImpl<$Res, _$FillDataImpl>
    implements _$$FillDataImplCopyWith<$Res> {
  __$$FillDataImplCopyWithImpl(
      _$FillDataImpl _value, $Res Function(_$FillDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokenAddressPath = null,
    Object? router = freezed,
  }) {
    return _then(_$FillDataImpl(
      tokenAddressPath: null == tokenAddressPath
          ? _value._tokenAddressPath
          : tokenAddressPath // ignore: cast_nullable_to_non_nullable
              as List<String>,
      router: freezed == router ? _value.router! : router,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FillDataImpl implements _FillData {
  const _$FillDataImpl(
      {required final List<String> tokenAddressPath, this.router = ""})
      : _tokenAddressPath = tokenAddressPath;

  factory _$FillDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$FillDataImplFromJson(json);

  final List<String> _tokenAddressPath;
  @override
  List<String> get tokenAddressPath {
    if (_tokenAddressPath is EqualUnmodifiableListView)
      return _tokenAddressPath;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tokenAddressPath);
  }

  @override
  @JsonKey()
  final dynamic router;

  @override
  String toString() {
    return 'FillData(tokenAddressPath: $tokenAddressPath, router: $router)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FillDataImpl &&
            const DeepCollectionEquality()
                .equals(other._tokenAddressPath, _tokenAddressPath) &&
            const DeepCollectionEquality().equals(other.router, router));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_tokenAddressPath),
      const DeepCollectionEquality().hash(router));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FillDataImplCopyWith<_$FillDataImpl> get copyWith =>
      __$$FillDataImplCopyWithImpl<_$FillDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FillDataImplToJson(
      this,
    );
  }
}

abstract class _FillData implements FillData {
  const factory _FillData(
      {required final List<String> tokenAddressPath,
      final dynamic router}) = _$FillDataImpl;

  factory _FillData.fromJson(Map<String, dynamic> json) =
      _$FillDataImpl.fromJson;

  @override
  List<String> get tokenAddressPath;
  @override
  dynamic get router;
  @override
  @JsonKey(ignore: true)
  _$$FillDataImplCopyWith<_$FillDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Source _$SourceFromJson(Map<String, dynamic> json) {
  return _Source.fromJson(json);
}

/// @nodoc
mixin _$Source {
  dynamic get name => throw _privateConstructorUsedError;
  dynamic get proportion => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SourceCopyWith<Source> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SourceCopyWith<$Res> {
  factory $SourceCopyWith(Source value, $Res Function(Source) then) =
      _$SourceCopyWithImpl<$Res, Source>;
  @useResult
  $Res call({dynamic name, dynamic proportion});
}

/// @nodoc
class _$SourceCopyWithImpl<$Res, $Val extends Source>
    implements $SourceCopyWith<$Res> {
  _$SourceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? proportion = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as dynamic,
      proportion: freezed == proportion
          ? _value.proportion
          : proportion // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SourceImplCopyWith<$Res> implements $SourceCopyWith<$Res> {
  factory _$$SourceImplCopyWith(
          _$SourceImpl value, $Res Function(_$SourceImpl) then) =
      __$$SourceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic name, dynamic proportion});
}

/// @nodoc
class __$$SourceImplCopyWithImpl<$Res>
    extends _$SourceCopyWithImpl<$Res, _$SourceImpl>
    implements _$$SourceImplCopyWith<$Res> {
  __$$SourceImplCopyWithImpl(
      _$SourceImpl _value, $Res Function(_$SourceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? proportion = freezed,
  }) {
    return _then(_$SourceImpl(
      name: freezed == name ? _value.name! : name,
      proportion: freezed == proportion ? _value.proportion! : proportion,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SourceImpl implements _Source {
  const _$SourceImpl({this.name = "", this.proportion = ""});

  factory _$SourceImpl.fromJson(Map<String, dynamic> json) =>
      _$$SourceImplFromJson(json);

  @override
  @JsonKey()
  final dynamic name;
  @override
  @JsonKey()
  final dynamic proportion;

  @override
  String toString() {
    return 'Source(name: $name, proportion: $proportion)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SourceImpl &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.proportion, proportion));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(proportion));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SourceImplCopyWith<_$SourceImpl> get copyWith =>
      __$$SourceImplCopyWithImpl<_$SourceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SourceImplToJson(
      this,
    );
  }
}

abstract class _Source implements Source {
  const factory _Source({final dynamic name, final dynamic proportion}) =
      _$SourceImpl;

  factory _Source.fromJson(Map<String, dynamic> json) = _$SourceImpl.fromJson;

  @override
  dynamic get name;
  @override
  dynamic get proportion;
  @override
  @JsonKey(ignore: true)
  _$$SourceImplCopyWith<_$SourceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
