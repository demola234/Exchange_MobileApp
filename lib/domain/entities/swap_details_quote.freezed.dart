// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'swap_details_quote.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SwapDetailsQuote _$SwapDetailsQuoteFromJson(Map<String, dynamic> json) {
  return _SwapDetailsQuote.fromJson(json);
}

/// @nodoc
mixin _$SwapDetailsQuote {
  dynamic get chainId => throw _privateConstructorUsedError;
  dynamic get price => throw _privateConstructorUsedError;
  dynamic get grossPrice => throw _privateConstructorUsedError;
  dynamic get estimatedPriceImpact => throw _privateConstructorUsedError;
  dynamic get value => throw _privateConstructorUsedError;
  dynamic get gasPrice => throw _privateConstructorUsedError;
  dynamic get gas => throw _privateConstructorUsedError;
  dynamic get estimatedGas => throw _privateConstructorUsedError;
  dynamic get protocolFee => throw _privateConstructorUsedError;
  dynamic get minimumProtocolFee => throw _privateConstructorUsedError;
  dynamic get buyTokenAddress => throw _privateConstructorUsedError;
  dynamic get buyAmount => throw _privateConstructorUsedError;
  dynamic get grossBuyAmount => throw _privateConstructorUsedError;
  dynamic get sellTokenAddress => throw _privateConstructorUsedError;
  dynamic get sellAmount => throw _privateConstructorUsedError;
  dynamic get grossSellAmount => throw _privateConstructorUsedError;
  List<Source>? get sources => throw _privateConstructorUsedError;
  dynamic get allowanceTarget => throw _privateConstructorUsedError;
  dynamic get sellTokenToEthRate => throw _privateConstructorUsedError;
  dynamic get buyTokenToEthRate => throw _privateConstructorUsedError;
  Fees? get fees => throw _privateConstructorUsedError;
  AuxiliaryChainData? get auxiliaryChainData =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SwapDetailsQuoteCopyWith<SwapDetailsQuote> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapDetailsQuoteCopyWith<$Res> {
  factory $SwapDetailsQuoteCopyWith(
          SwapDetailsQuote value, $Res Function(SwapDetailsQuote) then) =
      _$SwapDetailsQuoteCopyWithImpl<$Res, SwapDetailsQuote>;
  @useResult
  $Res call(
      {dynamic chainId,
      dynamic price,
      dynamic grossPrice,
      dynamic estimatedPriceImpact,
      dynamic value,
      dynamic gasPrice,
      dynamic gas,
      dynamic estimatedGas,
      dynamic protocolFee,
      dynamic minimumProtocolFee,
      dynamic buyTokenAddress,
      dynamic buyAmount,
      dynamic grossBuyAmount,
      dynamic sellTokenAddress,
      dynamic sellAmount,
      dynamic grossSellAmount,
      List<Source>? sources,
      dynamic allowanceTarget,
      dynamic sellTokenToEthRate,
      dynamic buyTokenToEthRate,
      Fees? fees,
      AuxiliaryChainData? auxiliaryChainData});

  $FeesCopyWith<$Res>? get fees;
  $AuxiliaryChainDataCopyWith<$Res>? get auxiliaryChainData;
}

/// @nodoc
class _$SwapDetailsQuoteCopyWithImpl<$Res, $Val extends SwapDetailsQuote>
    implements $SwapDetailsQuoteCopyWith<$Res> {
  _$SwapDetailsQuoteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainId = freezed,
    Object? price = freezed,
    Object? grossPrice = freezed,
    Object? estimatedPriceImpact = freezed,
    Object? value = freezed,
    Object? gasPrice = freezed,
    Object? gas = freezed,
    Object? estimatedGas = freezed,
    Object? protocolFee = freezed,
    Object? minimumProtocolFee = freezed,
    Object? buyTokenAddress = freezed,
    Object? buyAmount = freezed,
    Object? grossBuyAmount = freezed,
    Object? sellTokenAddress = freezed,
    Object? sellAmount = freezed,
    Object? grossSellAmount = freezed,
    Object? sources = freezed,
    Object? allowanceTarget = freezed,
    Object? sellTokenToEthRate = freezed,
    Object? buyTokenToEthRate = freezed,
    Object? fees = freezed,
    Object? auxiliaryChainData = freezed,
  }) {
    return _then(_value.copyWith(
      chainId: freezed == chainId
          ? _value.chainId
          : chainId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      price: freezed == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grossPrice: freezed == grossPrice
          ? _value.grossPrice
          : grossPrice // ignore: cast_nullable_to_non_nullable
              as dynamic,
      estimatedPriceImpact: freezed == estimatedPriceImpact
          ? _value.estimatedPriceImpact
          : estimatedPriceImpact // ignore: cast_nullable_to_non_nullable
              as dynamic,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
      gasPrice: freezed == gasPrice
          ? _value.gasPrice
          : gasPrice // ignore: cast_nullable_to_non_nullable
              as dynamic,
      gas: freezed == gas
          ? _value.gas
          : gas // ignore: cast_nullable_to_non_nullable
              as dynamic,
      estimatedGas: freezed == estimatedGas
          ? _value.estimatedGas
          : estimatedGas // ignore: cast_nullable_to_non_nullable
              as dynamic,
      protocolFee: freezed == protocolFee
          ? _value.protocolFee
          : protocolFee // ignore: cast_nullable_to_non_nullable
              as dynamic,
      minimumProtocolFee: freezed == minimumProtocolFee
          ? _value.minimumProtocolFee
          : minimumProtocolFee // ignore: cast_nullable_to_non_nullable
              as dynamic,
      buyTokenAddress: freezed == buyTokenAddress
          ? _value.buyTokenAddress
          : buyTokenAddress // ignore: cast_nullable_to_non_nullable
              as dynamic,
      buyAmount: freezed == buyAmount
          ? _value.buyAmount
          : buyAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grossBuyAmount: freezed == grossBuyAmount
          ? _value.grossBuyAmount
          : grossBuyAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sellTokenAddress: freezed == sellTokenAddress
          ? _value.sellTokenAddress
          : sellTokenAddress // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sellAmount: freezed == sellAmount
          ? _value.sellAmount
          : sellAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      grossSellAmount: freezed == grossSellAmount
          ? _value.grossSellAmount
          : grossSellAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sources: freezed == sources
          ? _value.sources
          : sources // ignore: cast_nullable_to_non_nullable
              as List<Source>?,
      allowanceTarget: freezed == allowanceTarget
          ? _value.allowanceTarget
          : allowanceTarget // ignore: cast_nullable_to_non_nullable
              as dynamic,
      sellTokenToEthRate: freezed == sellTokenToEthRate
          ? _value.sellTokenToEthRate
          : sellTokenToEthRate // ignore: cast_nullable_to_non_nullable
              as dynamic,
      buyTokenToEthRate: freezed == buyTokenToEthRate
          ? _value.buyTokenToEthRate
          : buyTokenToEthRate // ignore: cast_nullable_to_non_nullable
              as dynamic,
      fees: freezed == fees
          ? _value.fees
          : fees // ignore: cast_nullable_to_non_nullable
              as Fees?,
      auxiliaryChainData: freezed == auxiliaryChainData
          ? _value.auxiliaryChainData
          : auxiliaryChainData // ignore: cast_nullable_to_non_nullable
              as AuxiliaryChainData?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FeesCopyWith<$Res>? get fees {
    if (_value.fees == null) {
      return null;
    }

    return $FeesCopyWith<$Res>(_value.fees!, (value) {
      return _then(_value.copyWith(fees: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AuxiliaryChainDataCopyWith<$Res>? get auxiliaryChainData {
    if (_value.auxiliaryChainData == null) {
      return null;
    }

    return $AuxiliaryChainDataCopyWith<$Res>(_value.auxiliaryChainData!,
        (value) {
      return _then(_value.copyWith(auxiliaryChainData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SwapDetailsQuoteImplCopyWith<$Res>
    implements $SwapDetailsQuoteCopyWith<$Res> {
  factory _$$SwapDetailsQuoteImplCopyWith(_$SwapDetailsQuoteImpl value,
          $Res Function(_$SwapDetailsQuoteImpl) then) =
      __$$SwapDetailsQuoteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic chainId,
      dynamic price,
      dynamic grossPrice,
      dynamic estimatedPriceImpact,
      dynamic value,
      dynamic gasPrice,
      dynamic gas,
      dynamic estimatedGas,
      dynamic protocolFee,
      dynamic minimumProtocolFee,
      dynamic buyTokenAddress,
      dynamic buyAmount,
      dynamic grossBuyAmount,
      dynamic sellTokenAddress,
      dynamic sellAmount,
      dynamic grossSellAmount,
      List<Source>? sources,
      dynamic allowanceTarget,
      dynamic sellTokenToEthRate,
      dynamic buyTokenToEthRate,
      Fees? fees,
      AuxiliaryChainData? auxiliaryChainData});

  @override
  $FeesCopyWith<$Res>? get fees;
  @override
  $AuxiliaryChainDataCopyWith<$Res>? get auxiliaryChainData;
}

/// @nodoc
class __$$SwapDetailsQuoteImplCopyWithImpl<$Res>
    extends _$SwapDetailsQuoteCopyWithImpl<$Res, _$SwapDetailsQuoteImpl>
    implements _$$SwapDetailsQuoteImplCopyWith<$Res> {
  __$$SwapDetailsQuoteImplCopyWithImpl(_$SwapDetailsQuoteImpl _value,
      $Res Function(_$SwapDetailsQuoteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainId = freezed,
    Object? price = freezed,
    Object? grossPrice = freezed,
    Object? estimatedPriceImpact = freezed,
    Object? value = freezed,
    Object? gasPrice = freezed,
    Object? gas = freezed,
    Object? estimatedGas = freezed,
    Object? protocolFee = freezed,
    Object? minimumProtocolFee = freezed,
    Object? buyTokenAddress = freezed,
    Object? buyAmount = freezed,
    Object? grossBuyAmount = freezed,
    Object? sellTokenAddress = freezed,
    Object? sellAmount = freezed,
    Object? grossSellAmount = freezed,
    Object? sources = freezed,
    Object? allowanceTarget = freezed,
    Object? sellTokenToEthRate = freezed,
    Object? buyTokenToEthRate = freezed,
    Object? fees = freezed,
    Object? auxiliaryChainData = freezed,
  }) {
    return _then(_$SwapDetailsQuoteImpl(
      chainId: freezed == chainId ? _value.chainId! : chainId,
      price: freezed == price ? _value.price! : price,
      grossPrice: freezed == grossPrice ? _value.grossPrice! : grossPrice,
      estimatedPriceImpact: freezed == estimatedPriceImpact
          ? _value.estimatedPriceImpact!
          : estimatedPriceImpact,
      value: freezed == value ? _value.value! : value,
      gasPrice: freezed == gasPrice ? _value.gasPrice! : gasPrice,
      gas: freezed == gas ? _value.gas! : gas,
      estimatedGas:
          freezed == estimatedGas ? _value.estimatedGas! : estimatedGas,
      protocolFee: freezed == protocolFee ? _value.protocolFee! : protocolFee,
      minimumProtocolFee: freezed == minimumProtocolFee
          ? _value.minimumProtocolFee!
          : minimumProtocolFee,
      buyTokenAddress: freezed == buyTokenAddress
          ? _value.buyTokenAddress!
          : buyTokenAddress,
      buyAmount: freezed == buyAmount ? _value.buyAmount! : buyAmount,
      grossBuyAmount:
          freezed == grossBuyAmount ? _value.grossBuyAmount! : grossBuyAmount,
      sellTokenAddress: freezed == sellTokenAddress
          ? _value.sellTokenAddress!
          : sellTokenAddress,
      sellAmount: freezed == sellAmount ? _value.sellAmount! : sellAmount,
      grossSellAmount: freezed == grossSellAmount
          ? _value.grossSellAmount!
          : grossSellAmount,
      sources: freezed == sources
          ? _value._sources
          : sources // ignore: cast_nullable_to_non_nullable
              as List<Source>?,
      allowanceTarget: freezed == allowanceTarget
          ? _value.allowanceTarget!
          : allowanceTarget,
      sellTokenToEthRate: freezed == sellTokenToEthRate
          ? _value.sellTokenToEthRate!
          : sellTokenToEthRate,
      buyTokenToEthRate: freezed == buyTokenToEthRate
          ? _value.buyTokenToEthRate!
          : buyTokenToEthRate,
      fees: freezed == fees
          ? _value.fees
          : fees // ignore: cast_nullable_to_non_nullable
              as Fees?,
      auxiliaryChainData: freezed == auxiliaryChainData
          ? _value.auxiliaryChainData
          : auxiliaryChainData // ignore: cast_nullable_to_non_nullable
              as AuxiliaryChainData?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SwapDetailsQuoteImpl implements _SwapDetailsQuote {
  const _$SwapDetailsQuoteImpl(
      {this.chainId = 0,
      this.price = "",
      this.grossPrice = "",
      this.estimatedPriceImpact = "",
      this.value = "",
      this.gasPrice = "",
      this.gas = "",
      this.estimatedGas = "",
      this.protocolFee = "",
      this.minimumProtocolFee = "",
      this.buyTokenAddress = "",
      this.buyAmount = "",
      this.grossBuyAmount = "",
      this.sellTokenAddress = "",
      this.sellAmount = "",
      this.grossSellAmount = "",
      final List<Source>? sources,
      this.allowanceTarget = "",
      this.sellTokenToEthRate = "",
      this.buyTokenToEthRate = "",
      this.fees,
      this.auxiliaryChainData})
      : _sources = sources;

  factory _$SwapDetailsQuoteImpl.fromJson(Map<String, dynamic> json) =>
      _$$SwapDetailsQuoteImplFromJson(json);

  @override
  @JsonKey()
  final dynamic chainId;
  @override
  @JsonKey()
  final dynamic price;
  @override
  @JsonKey()
  final dynamic grossPrice;
  @override
  @JsonKey()
  final dynamic estimatedPriceImpact;
  @override
  @JsonKey()
  final dynamic value;
  @override
  @JsonKey()
  final dynamic gasPrice;
  @override
  @JsonKey()
  final dynamic gas;
  @override
  @JsonKey()
  final dynamic estimatedGas;
  @override
  @JsonKey()
  final dynamic protocolFee;
  @override
  @JsonKey()
  final dynamic minimumProtocolFee;
  @override
  @JsonKey()
  final dynamic buyTokenAddress;
  @override
  @JsonKey()
  final dynamic buyAmount;
  @override
  @JsonKey()
  final dynamic grossBuyAmount;
  @override
  @JsonKey()
  final dynamic sellTokenAddress;
  @override
  @JsonKey()
  final dynamic sellAmount;
  @override
  @JsonKey()
  final dynamic grossSellAmount;
  final List<Source>? _sources;
  @override
  List<Source>? get sources {
    final value = _sources;
    if (value == null) return null;
    if (_sources is EqualUnmodifiableListView) return _sources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final dynamic allowanceTarget;
  @override
  @JsonKey()
  final dynamic sellTokenToEthRate;
  @override
  @JsonKey()
  final dynamic buyTokenToEthRate;
  @override
  final Fees? fees;
  @override
  final AuxiliaryChainData? auxiliaryChainData;

  @override
  String toString() {
    return 'SwapDetailsQuote(chainId: $chainId, price: $price, grossPrice: $grossPrice, estimatedPriceImpact: $estimatedPriceImpact, value: $value, gasPrice: $gasPrice, gas: $gas, estimatedGas: $estimatedGas, protocolFee: $protocolFee, minimumProtocolFee: $minimumProtocolFee, buyTokenAddress: $buyTokenAddress, buyAmount: $buyAmount, grossBuyAmount: $grossBuyAmount, sellTokenAddress: $sellTokenAddress, sellAmount: $sellAmount, grossSellAmount: $grossSellAmount, sources: $sources, allowanceTarget: $allowanceTarget, sellTokenToEthRate: $sellTokenToEthRate, buyTokenToEthRate: $buyTokenToEthRate, fees: $fees, auxiliaryChainData: $auxiliaryChainData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapDetailsQuoteImpl &&
            const DeepCollectionEquality().equals(other.chainId, chainId) &&
            const DeepCollectionEquality().equals(other.price, price) &&
            const DeepCollectionEquality()
                .equals(other.grossPrice, grossPrice) &&
            const DeepCollectionEquality()
                .equals(other.estimatedPriceImpact, estimatedPriceImpact) &&
            const DeepCollectionEquality().equals(other.value, value) &&
            const DeepCollectionEquality().equals(other.gasPrice, gasPrice) &&
            const DeepCollectionEquality().equals(other.gas, gas) &&
            const DeepCollectionEquality()
                .equals(other.estimatedGas, estimatedGas) &&
            const DeepCollectionEquality()
                .equals(other.protocolFee, protocolFee) &&
            const DeepCollectionEquality()
                .equals(other.minimumProtocolFee, minimumProtocolFee) &&
            const DeepCollectionEquality()
                .equals(other.buyTokenAddress, buyTokenAddress) &&
            const DeepCollectionEquality().equals(other.buyAmount, buyAmount) &&
            const DeepCollectionEquality()
                .equals(other.grossBuyAmount, grossBuyAmount) &&
            const DeepCollectionEquality()
                .equals(other.sellTokenAddress, sellTokenAddress) &&
            const DeepCollectionEquality()
                .equals(other.sellAmount, sellAmount) &&
            const DeepCollectionEquality()
                .equals(other.grossSellAmount, grossSellAmount) &&
            const DeepCollectionEquality().equals(other._sources, _sources) &&
            const DeepCollectionEquality()
                .equals(other.allowanceTarget, allowanceTarget) &&
            const DeepCollectionEquality()
                .equals(other.sellTokenToEthRate, sellTokenToEthRate) &&
            const DeepCollectionEquality()
                .equals(other.buyTokenToEthRate, buyTokenToEthRate) &&
            (identical(other.fees, fees) || other.fees == fees) &&
            (identical(other.auxiliaryChainData, auxiliaryChainData) ||
                other.auxiliaryChainData == auxiliaryChainData));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        const DeepCollectionEquality().hash(chainId),
        const DeepCollectionEquality().hash(price),
        const DeepCollectionEquality().hash(grossPrice),
        const DeepCollectionEquality().hash(estimatedPriceImpact),
        const DeepCollectionEquality().hash(value),
        const DeepCollectionEquality().hash(gasPrice),
        const DeepCollectionEquality().hash(gas),
        const DeepCollectionEquality().hash(estimatedGas),
        const DeepCollectionEquality().hash(protocolFee),
        const DeepCollectionEquality().hash(minimumProtocolFee),
        const DeepCollectionEquality().hash(buyTokenAddress),
        const DeepCollectionEquality().hash(buyAmount),
        const DeepCollectionEquality().hash(grossBuyAmount),
        const DeepCollectionEquality().hash(sellTokenAddress),
        const DeepCollectionEquality().hash(sellAmount),
        const DeepCollectionEquality().hash(grossSellAmount),
        const DeepCollectionEquality().hash(_sources),
        const DeepCollectionEquality().hash(allowanceTarget),
        const DeepCollectionEquality().hash(sellTokenToEthRate),
        const DeepCollectionEquality().hash(buyTokenToEthRate),
        fees,
        auxiliaryChainData
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SwapDetailsQuoteImplCopyWith<_$SwapDetailsQuoteImpl> get copyWith =>
      __$$SwapDetailsQuoteImplCopyWithImpl<_$SwapDetailsQuoteImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SwapDetailsQuoteImplToJson(
      this,
    );
  }
}

abstract class _SwapDetailsQuote implements SwapDetailsQuote {
  const factory _SwapDetailsQuote(
      {final dynamic chainId,
      final dynamic price,
      final dynamic grossPrice,
      final dynamic estimatedPriceImpact,
      final dynamic value,
      final dynamic gasPrice,
      final dynamic gas,
      final dynamic estimatedGas,
      final dynamic protocolFee,
      final dynamic minimumProtocolFee,
      final dynamic buyTokenAddress,
      final dynamic buyAmount,
      final dynamic grossBuyAmount,
      final dynamic sellTokenAddress,
      final dynamic sellAmount,
      final dynamic grossSellAmount,
      final List<Source>? sources,
      final dynamic allowanceTarget,
      final dynamic sellTokenToEthRate,
      final dynamic buyTokenToEthRate,
      final Fees? fees,
      final AuxiliaryChainData? auxiliaryChainData}) = _$SwapDetailsQuoteImpl;

  factory _SwapDetailsQuote.fromJson(Map<String, dynamic> json) =
      _$SwapDetailsQuoteImpl.fromJson;

  @override
  dynamic get chainId;
  @override
  dynamic get price;
  @override
  dynamic get grossPrice;
  @override
  dynamic get estimatedPriceImpact;
  @override
  dynamic get value;
  @override
  dynamic get gasPrice;
  @override
  dynamic get gas;
  @override
  dynamic get estimatedGas;
  @override
  dynamic get protocolFee;
  @override
  dynamic get minimumProtocolFee;
  @override
  dynamic get buyTokenAddress;
  @override
  dynamic get buyAmount;
  @override
  dynamic get grossBuyAmount;
  @override
  dynamic get sellTokenAddress;
  @override
  dynamic get sellAmount;
  @override
  dynamic get grossSellAmount;
  @override
  List<Source>? get sources;
  @override
  dynamic get allowanceTarget;
  @override
  dynamic get sellTokenToEthRate;
  @override
  dynamic get buyTokenToEthRate;
  @override
  Fees? get fees;
  @override
  AuxiliaryChainData? get auxiliaryChainData;
  @override
  @JsonKey(ignore: true)
  _$$SwapDetailsQuoteImplCopyWith<_$SwapDetailsQuoteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AuxiliaryChainData _$AuxiliaryChainDataFromJson(Map<String, dynamic> json) {
  return _AuxiliaryChainData.fromJson(json);
}

/// @nodoc
mixin _$AuxiliaryChainData {
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuxiliaryChainDataCopyWith<$Res> {
  factory $AuxiliaryChainDataCopyWith(
          AuxiliaryChainData value, $Res Function(AuxiliaryChainData) then) =
      _$AuxiliaryChainDataCopyWithImpl<$Res, AuxiliaryChainData>;
}

/// @nodoc
class _$AuxiliaryChainDataCopyWithImpl<$Res, $Val extends AuxiliaryChainData>
    implements $AuxiliaryChainDataCopyWith<$Res> {
  _$AuxiliaryChainDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AuxiliaryChainDataImplCopyWith<$Res> {
  factory _$$AuxiliaryChainDataImplCopyWith(_$AuxiliaryChainDataImpl value,
          $Res Function(_$AuxiliaryChainDataImpl) then) =
      __$$AuxiliaryChainDataImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AuxiliaryChainDataImplCopyWithImpl<$Res>
    extends _$AuxiliaryChainDataCopyWithImpl<$Res, _$AuxiliaryChainDataImpl>
    implements _$$AuxiliaryChainDataImplCopyWith<$Res> {
  __$$AuxiliaryChainDataImplCopyWithImpl(_$AuxiliaryChainDataImpl _value,
      $Res Function(_$AuxiliaryChainDataImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$AuxiliaryChainDataImpl implements _AuxiliaryChainData {
  const _$AuxiliaryChainDataImpl();

  factory _$AuxiliaryChainDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuxiliaryChainDataImplFromJson(json);

  @override
  String toString() {
    return 'AuxiliaryChainData()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AuxiliaryChainDataImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  Map<String, dynamic> toJson() {
    return _$$AuxiliaryChainDataImplToJson(
      this,
    );
  }
}

abstract class _AuxiliaryChainData implements AuxiliaryChainData {
  const factory _AuxiliaryChainData() = _$AuxiliaryChainDataImpl;

  factory _AuxiliaryChainData.fromJson(Map<String, dynamic> json) =
      _$AuxiliaryChainDataImpl.fromJson;
}

Fees _$FeesFromJson(Map<String, dynamic> json) {
  return _Fees.fromJson(json);
}

/// @nodoc
mixin _$Fees {
  ZeroExFee? get zeroExFee => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FeesCopyWith<Fees> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeesCopyWith<$Res> {
  factory $FeesCopyWith(Fees value, $Res Function(Fees) then) =
      _$FeesCopyWithImpl<$Res, Fees>;
  @useResult
  $Res call({ZeroExFee? zeroExFee});

  $ZeroExFeeCopyWith<$Res>? get zeroExFee;
}

/// @nodoc
class _$FeesCopyWithImpl<$Res, $Val extends Fees>
    implements $FeesCopyWith<$Res> {
  _$FeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? zeroExFee = freezed,
  }) {
    return _then(_value.copyWith(
      zeroExFee: freezed == zeroExFee
          ? _value.zeroExFee
          : zeroExFee // ignore: cast_nullable_to_non_nullable
              as ZeroExFee?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ZeroExFeeCopyWith<$Res>? get zeroExFee {
    if (_value.zeroExFee == null) {
      return null;
    }

    return $ZeroExFeeCopyWith<$Res>(_value.zeroExFee!, (value) {
      return _then(_value.copyWith(zeroExFee: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FeesImplCopyWith<$Res> implements $FeesCopyWith<$Res> {
  factory _$$FeesImplCopyWith(
          _$FeesImpl value, $Res Function(_$FeesImpl) then) =
      __$$FeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({ZeroExFee? zeroExFee});

  @override
  $ZeroExFeeCopyWith<$Res>? get zeroExFee;
}

/// @nodoc
class __$$FeesImplCopyWithImpl<$Res>
    extends _$FeesCopyWithImpl<$Res, _$FeesImpl>
    implements _$$FeesImplCopyWith<$Res> {
  __$$FeesImplCopyWithImpl(_$FeesImpl _value, $Res Function(_$FeesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? zeroExFee = freezed,
  }) {
    return _then(_$FeesImpl(
      zeroExFee: freezed == zeroExFee
          ? _value.zeroExFee
          : zeroExFee // ignore: cast_nullable_to_non_nullable
              as ZeroExFee?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FeesImpl implements _Fees {
  const _$FeesImpl({this.zeroExFee});

  factory _$FeesImpl.fromJson(Map<String, dynamic> json) =>
      _$$FeesImplFromJson(json);

  @override
  final ZeroExFee? zeroExFee;

  @override
  String toString() {
    return 'Fees(zeroExFee: $zeroExFee)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeesImpl &&
            (identical(other.zeroExFee, zeroExFee) ||
                other.zeroExFee == zeroExFee));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, zeroExFee);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FeesImplCopyWith<_$FeesImpl> get copyWith =>
      __$$FeesImplCopyWithImpl<_$FeesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FeesImplToJson(
      this,
    );
  }
}

abstract class _Fees implements Fees {
  const factory _Fees({final ZeroExFee? zeroExFee}) = _$FeesImpl;

  factory _Fees.fromJson(Map<String, dynamic> json) = _$FeesImpl.fromJson;

  @override
  ZeroExFee? get zeroExFee;
  @override
  @JsonKey(ignore: true)
  _$$FeesImplCopyWith<_$FeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ZeroExFee _$ZeroExFeeFromJson(Map<String, dynamic> json) {
  return _ZeroExFee.fromJson(json);
}

/// @nodoc
mixin _$ZeroExFee {
  dynamic get feeType => throw _privateConstructorUsedError;
  dynamic get feeToken => throw _privateConstructorUsedError;
  dynamic get feeAmount => throw _privateConstructorUsedError;
  dynamic get billingType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ZeroExFeeCopyWith<ZeroExFee> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ZeroExFeeCopyWith<$Res> {
  factory $ZeroExFeeCopyWith(ZeroExFee value, $Res Function(ZeroExFee) then) =
      _$ZeroExFeeCopyWithImpl<$Res, ZeroExFee>;
  @useResult
  $Res call(
      {dynamic feeType,
      dynamic feeToken,
      dynamic feeAmount,
      dynamic billingType});
}

/// @nodoc
class _$ZeroExFeeCopyWithImpl<$Res, $Val extends ZeroExFee>
    implements $ZeroExFeeCopyWith<$Res> {
  _$ZeroExFeeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeType = freezed,
    Object? feeToken = freezed,
    Object? feeAmount = freezed,
    Object? billingType = freezed,
  }) {
    return _then(_value.copyWith(
      feeType: freezed == feeType
          ? _value.feeType
          : feeType // ignore: cast_nullable_to_non_nullable
              as dynamic,
      feeToken: freezed == feeToken
          ? _value.feeToken
          : feeToken // ignore: cast_nullable_to_non_nullable
              as dynamic,
      feeAmount: freezed == feeAmount
          ? _value.feeAmount
          : feeAmount // ignore: cast_nullable_to_non_nullable
              as dynamic,
      billingType: freezed == billingType
          ? _value.billingType
          : billingType // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ZeroExFeeImplCopyWith<$Res>
    implements $ZeroExFeeCopyWith<$Res> {
  factory _$$ZeroExFeeImplCopyWith(
          _$ZeroExFeeImpl value, $Res Function(_$ZeroExFeeImpl) then) =
      __$$ZeroExFeeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {dynamic feeType,
      dynamic feeToken,
      dynamic feeAmount,
      dynamic billingType});
}

/// @nodoc
class __$$ZeroExFeeImplCopyWithImpl<$Res>
    extends _$ZeroExFeeCopyWithImpl<$Res, _$ZeroExFeeImpl>
    implements _$$ZeroExFeeImplCopyWith<$Res> {
  __$$ZeroExFeeImplCopyWithImpl(
      _$ZeroExFeeImpl _value, $Res Function(_$ZeroExFeeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? feeType = freezed,
    Object? feeToken = freezed,
    Object? feeAmount = freezed,
    Object? billingType = freezed,
  }) {
    return _then(_$ZeroExFeeImpl(
      feeType: freezed == feeType ? _value.feeType! : feeType,
      feeToken: freezed == feeToken ? _value.feeToken! : feeToken,
      feeAmount: freezed == feeAmount ? _value.feeAmount! : feeAmount,
      billingType: freezed == billingType ? _value.billingType! : billingType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ZeroExFeeImpl implements _ZeroExFee {
  const _$ZeroExFeeImpl(
      {this.feeType = "",
      this.feeToken = "",
      this.feeAmount = "",
      this.billingType = ""});

  factory _$ZeroExFeeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ZeroExFeeImplFromJson(json);

  @override
  @JsonKey()
  final dynamic feeType;
  @override
  @JsonKey()
  final dynamic feeToken;
  @override
  @JsonKey()
  final dynamic feeAmount;
  @override
  @JsonKey()
  final dynamic billingType;

  @override
  String toString() {
    return 'ZeroExFee(feeType: $feeType, feeToken: $feeToken, feeAmount: $feeAmount, billingType: $billingType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ZeroExFeeImpl &&
            const DeepCollectionEquality().equals(other.feeType, feeType) &&
            const DeepCollectionEquality().equals(other.feeToken, feeToken) &&
            const DeepCollectionEquality().equals(other.feeAmount, feeAmount) &&
            const DeepCollectionEquality()
                .equals(other.billingType, billingType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(feeType),
      const DeepCollectionEquality().hash(feeToken),
      const DeepCollectionEquality().hash(feeAmount),
      const DeepCollectionEquality().hash(billingType));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ZeroExFeeImplCopyWith<_$ZeroExFeeImpl> get copyWith =>
      __$$ZeroExFeeImplCopyWithImpl<_$ZeroExFeeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ZeroExFeeImplToJson(
      this,
    );
  }
}

abstract class _ZeroExFee implements ZeroExFee {
  const factory _ZeroExFee(
      {final dynamic feeType,
      final dynamic feeToken,
      final dynamic feeAmount,
      final dynamic billingType}) = _$ZeroExFeeImpl;

  factory _ZeroExFee.fromJson(Map<String, dynamic> json) =
      _$ZeroExFeeImpl.fromJson;

  @override
  dynamic get feeType;
  @override
  dynamic get feeToken;
  @override
  dynamic get feeAmount;
  @override
  dynamic get billingType;
  @override
  @JsonKey(ignore: true)
  _$$ZeroExFeeImplCopyWith<_$ZeroExFeeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Source _$SourceFromJson(Map<String, dynamic> json) {
  return _Source.fromJson(json);
}

/// @nodoc
mixin _$Source {
  dynamic get name => throw _privateConstructorUsedError;
  dynamic get proportion => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SourceCopyWith<Source> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SourceCopyWith<$Res> {
  factory $SourceCopyWith(Source value, $Res Function(Source) then) =
      _$SourceCopyWithImpl<$Res, Source>;
  @useResult
  $Res call({dynamic name, dynamic proportion});
}

/// @nodoc
class _$SourceCopyWithImpl<$Res, $Val extends Source>
    implements $SourceCopyWith<$Res> {
  _$SourceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? proportion = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as dynamic,
      proportion: freezed == proportion
          ? _value.proportion
          : proportion // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SourceImplCopyWith<$Res> implements $SourceCopyWith<$Res> {
  factory _$$SourceImplCopyWith(
          _$SourceImpl value, $Res Function(_$SourceImpl) then) =
      __$$SourceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic name, dynamic proportion});
}

/// @nodoc
class __$$SourceImplCopyWithImpl<$Res>
    extends _$SourceCopyWithImpl<$Res, _$SourceImpl>
    implements _$$SourceImplCopyWith<$Res> {
  __$$SourceImplCopyWithImpl(
      _$SourceImpl _value, $Res Function(_$SourceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? proportion = freezed,
  }) {
    return _then(_$SourceImpl(
      name: freezed == name ? _value.name! : name,
      proportion: freezed == proportion ? _value.proportion! : proportion,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SourceImpl implements _Source {
  const _$SourceImpl({this.name = "", this.proportion = ""});

  factory _$SourceImpl.fromJson(Map<String, dynamic> json) =>
      _$$SourceImplFromJson(json);

  @override
  @JsonKey()
  final dynamic name;
  @override
  @JsonKey()
  final dynamic proportion;

  @override
  String toString() {
    return 'Source(name: $name, proportion: $proportion)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SourceImpl &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.proportion, proportion));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(proportion));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SourceImplCopyWith<_$SourceImpl> get copyWith =>
      __$$SourceImplCopyWithImpl<_$SourceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SourceImplToJson(
      this,
    );
  }
}

abstract class _Source implements Source {
  const factory _Source({final dynamic name, final dynamic proportion}) =
      _$SourceImpl;

  factory _Source.fromJson(Map<String, dynamic> json) = _$SourceImpl.fromJson;

  @override
  dynamic get name;
  @override
  dynamic get proportion;
  @override
  @JsonKey(ignore: true)
  _$$SourceImplCopyWith<_$SourceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
